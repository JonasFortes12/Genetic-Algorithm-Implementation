population_size = 200;
population = initializePopulation(population_size);
max_genenerations = 200;
generation = 1;

while (generation <= maxGenerations)
    
    population_score = getAvaliation(population);
    population_rank = definePopulationRanking(population, population_score);

    [parents, bestIndividual, bestScore, bestChance, worstIndividual, worstScore, worstChance] = selectParents(population_rank);
    
    % Cross parents
    children = crossover(parents);
    
    % Update population
    population = children;
    
    % elitism - preserves the best individual
    population(round(rand()*(population_size-1) + 1), :) = bestIndividual; 

    bestIndividualDec = convert_bin2dec(bestIndividual);
    bestIndividualX = round(bestIndividualDec(1),4);
    bestIndividualY = round(bestIndividualDec(2),4);
    worstIndividualDec = convert_bin2dec(worstIndividual);
    worstIndividualX = round(worstIndividualDec(1),4);
    worstIndividualY = round(worstIndividualDec(2),4);

    disp("Geração: " + generation);
    disp("Melhor Individuo: X = " + bestIndividualX + ", Y = " + bestIndividualY);
    disp("Pior Individuo: X = " + worstIndividualX + ", Y = " + worstIndividualY);
    disp("Melhor Nota: " + bestScore+ " (" + bestChance*100 + "% na roleta)");
    disp("Pior Nota: " + worstScore + " (" + worstChance*100 + "% na roleta)");
    disp("Nota Média: " + mean(population_score));
    disp(" ")
    generation = generation + 1;
end


function population = initializePopulation(population_size)
    population = randi([0, 1], population_size, 40, 'logical');
end


function populationRanking = definePopulationRanking(population, populationScore)

    % Ranking population
    population_ranking = [population, populationScore];
    population_ranking = sortrows(population_ranking, 41, 'descend');

    populationRanking = population_ranking;

end


function avaliation = getAvaliation(population)
    
    % convert binary values ​​to real values ​​in the search space. Range [-10 10]
    xy_values = convert_bin2dec(population);
    x = xy_values(:,1);
    y = xy_values(:,2);

    % Calculate the ackey function result
    ackey_result = -20 * exp(-0.2 * (0.5*(x.^2 + y.^2)).^(1/2)) - exp(0.5*(cos(2*pi*x) + cos(2*pi*y))) + exp(1) + 20;
    
    % Normalize the result of the ackley function to an evaluation value for the individual
    avaliation = (25./(ackey_result+1))*4;
end


function [crossGene1, crossGene2] = crossGenes(gene_A, gene_B)
    % define random cut point (between index 2 and 18)
    cut = 2 + round(rand()*16); 
    
    crossGene1 = [gene_A(1:cut) , gene_B((cut+1):20)];
    crossGene2 = [gene_B(1:cut) , gene_A((cut+1):20)];
    
    % adding probability of 0.5% of mutation in each cross gene
    for i=1:20
        if (rand()<0.005)
            crossGene1(i) = not(crossGene1(i));
        end
        if (rand()<0.005)
            crossGene2(i) = not(crossGene2(i));
        end
    end

end


function children = crossover(parents)
    num_parents = length(parents);
    population_size = 2*num_parents;
    children = zeros(population_size, 40);

    for i = 1:(cast(num_parents/2, "uint8"))
        
        % Select 3 parents in each iteration of crossover 
        parent_A = parents(i,:);
        gene_A1 = parent_A(1,1:20);
        gene_A2 = parent_A(1,21:40);
        
        parent_B = parents((i+(cast(num_parents/4,"uint8"))),:);
        gene_B1 = parent_B(1,1:20);
        gene_B2 = parent_B(1,21:40);
        
        % random parent C
        parent_C = parents(round(1 + rand()*(num_parents - 1)),:); 
        gene_C1 = parent_C(1,1:20);
        gene_C2 = parent_C(1,21:40);
        
        
        % realizing crossover and generating 4 children for each cross
        % Crossing parental genes        
        [crossGene_AB1, crossGene_AB2] = crossGenes(gene_A1, gene_B1);
        [crossGene_AB3, crossGene_AB4] = crossGenes(gene_A2, gene_B2);

        child_1 = [crossGene_AB1, crossGene_AB3];
        child_2 = [crossGene_AB2, crossGene_AB4];

        [crossGene_AC1, crossGene_AC2] = crossGenes(gene_A1, gene_C1);
        [crossGene_AC3, crossGene_AC4] = crossGenes(gene_A2, gene_C2);

        child_3 = [crossGene_AC1, crossGene_AC3];
        child_4 = [crossGene_AC2, crossGene_AC4];


        % Repopulating children with the children generated by crossing
        children( ((4*i) - 3) , : ) = child_1;
        children( ((4*i) - 2) , : ) = child_2;
        children( ((4*i) - 1) , : ) = child_3;
        children( ((4*i) - 0) , : ) = child_4;
    end


end


function xy_values = convert_bin2dec(element)
    
    % get binaries individuals or binaries population
    x_bin = element(:,1:20)';
    y_bin = element(:,21:40)';

    x_dec = bit2int(x_bin, 20)';
    y_dec = bit2int(y_bin, 20)';

    % convert binary values ​​to real values ​​in the range [-10 10]
    x = -10 + x_dec*((10 - (-10))/(2^20 - 1));
    y = -10 + y_dec*((10 - (-10))/(2^20 - 1));
    
    xy_values = [x, y];
end


function [parents, bestIndividual, bestScore, bestChance, worstIndividual, worstScore, worstChance] = selectParents(population_ranking)
    
    sum_score = sum(population_ranking(:,41));
    population_size = length(population_ranking);

    % Dfines best individual infos
    bestIndividual = population_ranking(1,1:40);
    bestScore = population_ranking(1,41);
    bestChance = round(bestScore/sum_score,4);

    % Dfines worst individual infos
    worstIndividual = population_ranking(population_size,1:40);
    worstScore = population_ranking(population_size,41);
    worstChance = round(worstScore/sum_score,4);
    
    parents = zeros(population_size/2 , 40);
    
    % roulette
    j = 1;
    while (j <= length(parents))
        sortedNum = sum_score*rand();
       
        i = 1; % Individual index

       accumulated_score = population_ranking(i,41);
       while (accumulated_score < sortedNum)
         i = i + 1;
         accumulated_score = accumulated_score + population_ranking(i,41);
       end
       
       % Select a parent
       parents(j,:) = population_ranking(i,1:40);

       j = j + 1;
    end

end


