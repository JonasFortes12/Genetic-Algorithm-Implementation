population_size = 200;
population = initializePopulation(population_size);
max_genenerations = 300;
generation = 1; %Count generation

count_same_bestIndividual = 0;
current_bestIndividual = zeros(1,40);

while (generation <= max_genenerations)
    
    % Evaluates the current population 
    population_score = getAvaliation(population);

    % Defines the population ranking
    population_rank = definePopulationRanking(population, population_score);

    % Selects the best parents from the population and extracts information
    [parents, bestIndividual, bestScore, bestChance, worstIndividual, worstScore, worstChance] = selectParents(population_rank);

    % Checks stagnation of the best individual 
    if (bestIndividual == current_bestIndividual)
        count_same_bestIndividual = count_same_bestIndividual + 1;
    else
        count_same_bestIndividual = 0;
    end
    if count_same_bestIndividual > 70
        break;
    end
    current_bestIndividual = bestIndividual;
   

    % Parent crossing
    children = crossover(parents);
    
    % Update population
    population = children;
    
    % elitism - preserves the best individual
    population(round(rand()*(population_size-1) + 1), :) = bestIndividual; 

    % Show current population informations
    showGenerationInfo(generation,bestIndividual,bestScore,worstIndividual,worstScore,bestChance,worstChance,population_score);

    % Advance to the next generation
    generation = generation + 1;
end

% Show graph results
plotGraph(current_bestIndividual);

function population = initializePopulation(population_size)
    population = randi([0, 1], population_size, 40, 'logical');
end


function populationRanking = definePopulationRanking(population, populationScore)

    % Ranking population
    population_ranking = [population, populationScore];
    population_ranking = sortrows(population_ranking, 41, 'descend');

    populationRanking = population_ranking;

end


function avaliation = getAvaliation(population)
    
    % convert binary values ​​to real values ​​in the search space. Range [-10 10]
    xy_values = convert_bin2dec(population);
    x = xy_values(:,1);
    y = xy_values(:,2);

    % Calculate the ackey function result
    ackey_result = -20 * exp(-0.2 * (0.5*(x.^2 + y.^2)).^(1/2)) - exp(0.5*(cos(2*pi*x) + cos(2*pi*y))) + exp(1) + 20;
    
    % Normalize the result of the ackley function to an evaluation value for the individual
    avaliation = (25./(ackey_result+1))*4;
end


function [crossGene1, crossGene2] = crossGenes(gene_A, gene_B)
    % define random cut point (between index 2 and 18)
    cut = 2 + round(rand()*16); 
    
    crossGene1 = [gene_A(1:cut) , gene_B((cut+1):20)];
    crossGene2 = [gene_B(1:cut) , gene_A((cut+1):20)];
    
    % adding probability of 0.5% of mutation in each cross gene
    for i=1:20
        if (rand()<0.005)
            crossGene1(i) = not(crossGene1(i));
        end
        if (rand()<0.005)
            crossGene2(i) = not(crossGene2(i));
        end
    end

end


function children = crossover(parents)
    num_parents = length(parents);
    population_size = 2*num_parents;
    children = zeros(population_size, 40);

    for i = 1:(cast(num_parents/2, "uint8"))
        
        % Select 3 parents in each iteration of crossover 
        parent_A = parents(i,:);
        gene_A1 = parent_A(1,1:20);
        gene_A2 = parent_A(1,21:40);
        
        parent_B = parents((i+(cast(num_parents/4,"uint8"))),:);
        gene_B1 = parent_B(1,1:20);
        gene_B2 = parent_B(1,21:40);
        
        % random parent C
        parent_C = parents(round(1 + rand()*(num_parents - 1)),:); 
        gene_C1 = parent_C(1,1:20);
        gene_C2 = parent_C(1,21:40);
        
        
        % realizing crossover and generating 4 children for each cross
        % Crossing parental genes        
        [crossGene_AB1, crossGene_AB2] = crossGenes(gene_A1, gene_B1);
        [crossGene_AB3, crossGene_AB4] = crossGenes(gene_A2, gene_B2);

        child_1 = [crossGene_AB1, crossGene_AB3];
        child_2 = [crossGene_AB2, crossGene_AB4];

        [crossGene_AC1, crossGene_AC2] = crossGenes(gene_A1, gene_C1);
        [crossGene_AC3, crossGene_AC4] = crossGenes(gene_A2, gene_C2);

        child_3 = [crossGene_AC1, crossGene_AC3];
        child_4 = [crossGene_AC2, crossGene_AC4];


        % Repopulating children with the children generated by crossing
        children( ((4*i) - 3) , : ) = child_1;
        children( ((4*i) - 2) , : ) = child_2;
        children( ((4*i) - 1) , : ) = child_3;
        children( ((4*i) - 0) , : ) = child_4;
    end


end


function xy_values = convert_bin2dec(element)
    
    % get binaries individuals or binaries population
    x_bin = element(:,1:20)';
    y_bin = element(:,21:40)';

    x_dec = bit2int(x_bin, 20)';
    y_dec = bit2int(y_bin, 20)';

    % convert binary values ​​to real values ​​in the range [-10 10]
    x = -10 + x_dec*((10 - (-10))/(2^20 - 1));
    y = -10 + y_dec*((10 - (-10))/(2^20 - 1));
    
    xy_values = [x, y];
end


function [parents, bestIndividual, bestScore, bestChance, worstIndividual, worstScore, worstChance] = selectParents(population_ranking)
    
    sum_score = sum(population_ranking(:,41));
    population_size = length(population_ranking);

    % Dfines best individual infos
    bestIndividual = population_ranking(1,1:40);
    bestScore = population_ranking(1,41);
    bestChance = round(bestScore/sum_score,4);

    % Dfines worst individual infos
    worstIndividual = population_ranking(population_size,1:40);
    worstScore = population_ranking(population_size,41);
    worstChance = round(worstScore/sum_score,4);
    
    parents = zeros(population_size/2 , 40);
    
    % roulette
    j = 1;
    while (j <= length(parents))
        sortedNum = sum_score*rand();
       
        i = 1; % Individual index

       accumulated_score = population_ranking(i,41);
       while (accumulated_score < sortedNum)
         i = i + 1;
         accumulated_score = accumulated_score + population_ranking(i,41);
       end
       
       % Select a parent
       parents(j,:) = population_ranking(i,1:40);

       j = j + 1;
    end

end


function showGenerationInfo(generation, bestIndividual, bestScore, worstIndividual, worstScore, bestChance, worstChance, population_score )

    bestIndividual = convert_bin2dec(bestIndividual);
    bestIndividual_x = round(bestIndividual(1),4);
    bestIndividual_y = round(bestIndividual(2),4);
    
    worstIndividual = convert_bin2dec(worstIndividual);
    worstIndividual_x = round(worstIndividual(1),4);
    worstIndividual_y = round(worstIndividual(2),4);
    bestChance = bestChance * 100;
    worstChance = worstChance * 100;
    fprintf('__________________________________________________________\n');
    fprintf('Número da Geração: %d\n', generation);
    fprintf('Melhor Individuo: X = %.4f, Y = %.4f\n', bestIndividual_x, bestIndividual_y);
    fprintf('Pior Individuo: X = %.4f, Y = %.4f\n', worstIndividual_x, worstIndividual_y);
    fprintf('Melhor Nota: %.4f (%.2f%% na roleta)\n', bestScore, bestChance);
    fprintf('Pior Nota: %.4f (%.2f%% na roleta)\n', worstScore, worstChance);
    fprintf('Nota Média: %.4f\n\n', mean(population_score));

end

function plotGraph(bestIndividual)
    
    bestIndividual = convert_bin2dec(bestIndividual);
    bestIndividual_x = round(bestIndividual(1),4);
    bestIndividual_y = round(bestIndividual(2),4);

    % Define the Ackley function
    ackley = @(x, y) -20 * exp(-0.2 * sqrt(0.5*(x.^2 + y.^2))) - exp(0.5*(cos(2*pi*x) + cos(2*pi*y))) + exp(1) + 20;
    
    % Generate a grid of points for plotting
    x_values = linspace(-10, 10, 100);  % Ajuste conforme necessário
    y_values = linspace(-10, 10, 100);  % Ajuste conforme necessário
    [X, Y] = meshgrid(x_values, y_values);
    Z = ackley(X, Y);
    
    % Plotar Ackley function - search space
    figure;
    surf(X, Y, Z, 'EdgeColor', 'none');
    xlabel('X');
    ylabel('Y');
    zlabel('Ackley(x, y)');
    title('Função Ackley em 3D');

    % Plot best individual mark
    hold on;
    plot(bestIndividual_x, bestIndividual_y, 'ro', 'MarkerSize', 10, 'LineWidth', 3);
    hold off;

end
